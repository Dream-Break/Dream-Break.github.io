<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java序列化有什么作用？序列化与不序列化有什么区别？</title>
    <url>/blog/2021/03/19/Java-Serializable/</url>
    <content><![CDATA[<p>作者：CodeSheep程序羊<br>链接：<a href="https://www.zhihu.com/question/26475281/answer/1257699781">https://www.zhihu.com/question/26475281/answer/1257699781</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="序列化是干啥用的？"><a href="#序列化是干啥用的？" class="headerlink" title="序列化是干啥用的？"></a><strong>序列化是干啥用的？</strong></h2><p>序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：</p>
<ul>
<li><strong>序列化</strong>：把Java对象转换为字节序列。</li>
<li><strong>反序列化</strong>：把字节序列恢复为原先的Java对象。</li>
</ul>
<p><img src="https://pic1.zhimg.com/50/v2-d5b7da5ee39eef8754554efb392e7668_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d5b7da5ee39eef8754554efb392e7668_720w.jpg?source=1940ef5c" alt="img"></p>
<p>而且序列化机制从某种意义上来说也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。</p>
<p>事情就是那么个事情，看起来很简单，不过后面的东西还不少，请往下看。</p>
<hr>
<h2 id="对象如何序列化？"><a href="#对象如何序列化？" class="headerlink" title="对象如何序列化？"></a><strong>对象如何序列化？</strong></h2><p>然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。</p>
<p>对象的持久化和反持久化需要靠程序员在代码里手动<strong>显式地</strong>进行序列化和反序列化还原的动作。</p>
<p>举个例子，假如我们要对<code>Student</code>类对象序列化到一个名为<code>student.txt</code>的文本文件中，然后再通过文本文件反序列化成<code>Student</code>类对象：</p>
<p><img src="https://pic4.zhimg.com/50/v2-b176ec7a4fef630598ee4f69743e56ac_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-b176ec7a4fef630598ee4f69743e56ac_720w.jpg?source=1940ef5c" alt="img"></p>
<p>1、Student类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student:&quot;</span> + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;name = &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;age = &quot;</span> + <span class="keyword">this</span>.age + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;score = &quot;</span> + <span class="keyword">this</span>.score + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectOutputStream( <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;序列化成功！已经生成student.txt文件&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;==============================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream objectInputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectInputStream( <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    Student student = (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行结果</p>
<p>控制台打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">序列化成功！已经生成student.txt文件</span><br><span class="line">==============================================</span><br><span class="line">反序列化结果为：</span><br><span class="line">Student:</span><br><span class="line">name = CodeSheep</span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">score = <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Serializable接口有何用？"><a href="#Serializable接口有何用？" class="headerlink" title="Serializable接口有何用？"></a><strong>Serializable接口有何用？</strong></h2><p>上面在定义<code>Student</code>类时，实现了一个<code>Serializable</code>接口，然而当我们点进<code>Serializable</code>接口内部查看，发现它<strong>竟然是一个空接口</strong>，并没有包含任何方法！</p>
<p><img src="https://pic2.zhimg.com/50/v2-946e2589cfddb10080f42d072d4ec4fe_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-946e2589cfddb10080f42d072d4ec4fe_720w.jpg?source=1940ef5c" alt="img"></p>
<p>试想，如果上面在定义<code>Student</code>类时忘了加<code>implements Serializable</code>时会发生什么呢？</p>
<p>实验结果是：此时的程序运行<strong>会报错</strong>，并抛出<code>NotSerializableException</code>异常：</p>
<p><img src="https://pic4.zhimg.com/50/v2-2715eb902b48b0d13e2ec788b62d8d99_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-2715eb902b48b0d13e2ec788b62d8d99_720w.jpg?source=1940ef5c" alt="img"></p>
<p>我们按照错误提示，由源码一直跟到<code>ObjectOutputStream</code>的<code>writeObject0()</code>方法底层一看，才恍然大悟：</p>
<p><img src="https://pic4.zhimg.com/50/v2-bde7f25f1ed5d0aaf76c12d12554795d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-bde7f25f1ed5d0aaf76c12d12554795d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>如果一个对象既不是<strong>字符串</strong>、<strong>数组</strong>、<strong>枚举</strong>，而且也没有实现<code>Serializable</code>接口的话，在序列化时就会抛出<code>NotSerializableException</code>异常！</p>
<p>哦，我明白了！</p>
<p>原来<code>Serializable</code>接口也仅仅只是做一个标记用！！！</p>
<p>它告诉代码只要是实现了<code>Serializable</code>接口的类都是可以被序列化的！然而真正的序列化动作不需要靠它完成。</p>
<hr>
<h2 id="serialVersionUID号有何用？"><a href="#serialVersionUID号有何用？" class="headerlink" title="serialVersionUID号有何用？"></a><strong><code>serialVersionUID</code>号有何用？</strong></h2><p>相信你一定经常看到有些类中定义了如下代码行，即定义了一个名为<code>serialVersionUID</code>的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4392658638228508589L</span>;</span><br></pre></td></tr></table></figure>

<p><strong>你知道这句声明的含义吗？为什么要搞一个名为<code>serialVersionUID</code>的序列号？</strong></p>
<p>继续来做一个简单实验，还拿上面的<code>Student</code>类为例，我们并没有人为在里面显式地声明一个<code>serialVersionUID</code>字段。</p>
<p>我们首先还是调用上面的<code>serialize()</code>方法，将一个<code>Student</code>对象序列化到本地磁盘上的<code>student.txt</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectOutputStream( <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们在<code>Student</code>类里面动点手脚，比如在里面再增加一个名为<code>studentID</code>的字段，表示学生学号：</p>
<p><img src="https://pic2.zhimg.com/50/v2-d6f5db64071b4ff61a4fdbedcab3a4ec_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d6f5db64071b4ff61a4fdbedcab3a4ec_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这时候，我们拿刚才已经序列化到本地的<code>student.txt</code>文件，还用如下代码进行反序列化，试图还原出刚才那个<code>Student</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream objectInputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectInputStream( <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    Student student = (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现<strong>报错了</strong>，并且抛出了<code>InvalidClassException</code>异常：</p>
<p><img src="https://pic1.zhimg.com/50/v2-21a3779d602dec56312ec2006059d568_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-21a3779d602dec56312ec2006059d568_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这地方提示的信息非常明确了：序列化前后的<code>serialVersionUID</code>号码不兼容！</p>
<p>从这地方最起码可以得出<strong>两个</strong>重要信息：</p>
<ul>
<li><strong>1、serialVersionUID是序列化前后的唯一标识符</strong></li>
<li><strong>2、默认如果没有人为显式定义过<code>serialVersionUID</code>，那编译器会为它自动声明一个！</strong></li>
</ul>
<p><strong>第1个问题：</strong> <code>serialVersionUID</code>序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。</p>
<p><strong>第2个问题：</strong> 如果在定义一个可序列化的类时，没有人为显式地给它定义一个<code>serialVersionUID</code>的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的<code>serialVersionUID</code>，一旦像上面一样更改了类的结构或者信息，则类的<code>serialVersionUID</code>也会跟着变化！</p>
<p>所以，为了<code>serialVersionUID</code>的确定性，写代码时还是建议，凡是<code>implements Serializable</code>的类，都最好人为显式地为它声明一个<code>serialVersionUID</code>明确值！</p>
<p>当然，如果不想手动赋值，你也可以借助IDE的自动添加功能，比如我使用的<code>IntelliJ IDEA</code>，按<code>alt + enter</code>就可以为类自动生成和添加<code>serialVersionUID</code>字段，十分方便：</p>
<p><img src="https://pic2.zhimg.com/50/v2-58dd50e1816eb241d3057b41e421da3c_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-58dd50e1816eb241d3057b41e421da3c_720w.jpg?source=1940ef5c" alt="img"></p>
<hr>
<h2 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a><strong>两种特殊情况</strong></h2><ul>
<li>1、凡是被<code>static</code>修饰的字段是不会被序列化的</li>
<li>2、凡是被<code>transient</code>修饰符修饰的字段也是不会被序列化的</li>
</ul>
<p><strong>对于第一点</strong>，因为序列化保存的是<strong>对象的状态</strong>而非类的状态，所以会忽略<code>static</code>静态域也是理所应当的。</p>
<p><strong>对于第二点</strong>，就需要了解一下<code>transient</code>修饰符的作用了。</p>
<p>如果在序列化某个类的对象时，就是不希望某个字段被序列化（比如这个字段存放的是隐私值，如：<code>密码</code>等），那这时就可以用<code>transient</code>修饰符来修饰该字段。</p>
<p>比如在之前定义的<code>Student</code>类中，加入一个<strong>密码字段</strong>，但是不希望序列化到<code>txt</code>文本，则可以：</p>
<p><img src="https://pic4.zhimg.com/50/v2-2e8e361785961716c6ce2168ad943faa_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-2e8e361785961716c6ce2168ad943faa_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这样在序列化<code>Student</code>类对象时，<code>password</code>字段会设置为默认值<code>null</code>，这一点可以从反序列化所得到的结果来看出：</p>
<p><img src="https://pic4.zhimg.com/50/v2-52e8cd9f0b6d2b9c926cbd4d276c95e7_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-52e8cd9f0b6d2b9c926cbd4d276c95e7_720w.jpg?source=1940ef5c" alt="img"></p>
<hr>
<h2 id="序列化的受控和加强"><a href="#序列化的受控和加强" class="headerlink" title="序列化的受控和加强"></a><strong>序列化的受控和加强</strong></h2><h2 id="约束性加持"><a href="#约束性加持" class="headerlink" title="约束性加持"></a><strong>约束性加持</strong></h2><p>从上面的过程可以看出，序列化和反序列化的过程其实是<strong>有漏洞的</strong>，因为从序列化到反序列化是有中间过程的，如果被别人拿到了中间字节流，然后加以伪造或者篡改，那反序列化出来的对象就会有一定风险了。</p>
<p>毕竟反序列化也相当于一种 <strong>“隐式的”对象构造</strong> ，因此我们希望在反序列化时，进行<strong>受控的</strong>对象反序列化动作。</p>
<p>那怎么个受控法呢？</p>
<p><strong>答案就是：</strong> 自行编写<code>readObject()</code>函数，用于对象的反序列化构造，从而提供约束性。</p>
<p>既然自行编写<code>readObject()</code>函数，那就可以做很多可控的事情：比如各种判断工作。</p>
<p>还以上面的<code>Student</code>类为例，一般来说学生的成绩应该在<code>0 ~ 100</code>之间，我们为了防止学生的考试成绩在反序列化时被别人篡改成一个奇葩值，我们可以自行编写<code>readObject()</code>函数用于反序列化的控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">( ObjectInputStream objectInputStream )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用默认的反序列化函数</span></span><br><span class="line">    objectInputStream.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手工检查反序列化后学生成绩的有效性，若发现有问题，即终止操作！</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> &gt; score || <span class="number">100</span> &lt; score ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;学生分数只能在0到100之间！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我故意将学生的分数改为<code>101</code>，此时反序列化立马终止并且报错：</p>
<p><img src="https://pic2.zhimg.com/50/v2-4713bd13ff5dba64ffdcc477c7f7f3a2_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4713bd13ff5dba64ffdcc477c7f7f3a2_720w.jpg?source=1940ef5c" alt="img"></p>
<p>对于上面的代码，有些小伙伴可能会好奇，为什么自定义的<code>private</code>的<code>readObject()</code>方法可以被自动调用，这就需要你跟一下底层源码来一探究竟了，我帮你跟到了<code>ObjectStreamClass</code>类的最底层，看到这里我相信你一定恍然大悟：</p>
<p><img src="https://pic3.zhimg.com/50/v2-a047fdae29d82d8682e05cf4cbef587a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-a047fdae29d82d8682e05cf4cbef587a_720w.jpg?source=1940ef5c" alt="img"></p>
<p>又是反射机制在起作用！是的，在Java里，果然万物皆可“反射”（滑稽），即使是类中定义的<code>private</code>私有方法，也能被抠出来执行了，简直引起舒适了。</p>
<h2 id="单例模式增强"><a href="#单例模式增强" class="headerlink" title="单例模式增强"></a><strong>单例模式增强</strong></h2><p>一个容易被忽略的问题是：<strong>可序列化的单例类有可能并不单例</strong>！</p>
<p>举个代码小例子就清楚了。</p>
<p>比如这里我们先用<code>java</code>写一个常见的「静态内部类」方式的单例模式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1576643344804979563L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写一个验证主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream =</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将单例对象先序列化到文本文件singleton.txt中</span></span><br><span class="line">        objectOutputStream.writeObject( Singleton.getSingleton() );</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream =</span><br><span class="line">                <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将文本文件singleton.txt中的对象反序列化为singleton1</span></span><br><span class="line">        Singleton singleton1 = (Singleton) objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line"></span><br><span class="line">        Singleton singleton2 = Singleton.getSingleton();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行结果竟打印 false ！</span></span><br><span class="line">        System.out.println( singleton1 == singleton2 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后我们发现：<strong>反序列化后的单例对象和原单例对象并不相等</strong>了，这无疑没有达到我们的目标。</p>
<p><strong>解决办法是</strong>：在单例类中手写<code>readResolve()</code>函数，直接返回单例对象，来规避之：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/50/v2-a2eb19f73a2ac3365bb368f10ca0635d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-a2eb19f73a2ac3365bb368f10ca0635d_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这样一来，当反序列化从流中读取对象时，<code>readResolve()</code>会被调用，用其中返回的对象替代反序列化新建的对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Serializable</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS详解</title>
    <url>/blog/2021/03/21/AbstractQueuedSynchronizer/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>AQS是AbstractQueuedSychronizer类的简称，虽然我们不会直接使用这个类，但是这个类是Java很多并发工具的实现。</p>
<h1 id="实现AQS的类"><a href="#实现AQS的类" class="headerlink" title="实现AQS的类"></a>实现AQS的类</h1><p>使用IDEA可以看到，以下类是使用AQS实现的：</p>
<p><img src="https://p3-open.byteimg.com/img/pgc-image/d16a2a71abe644a0b7faec84c6f91565~640x0.jpeg" alt="面试必问的AQS（AbstractQueuedSynchronizer），一次性全搞定"></p>
<p>可以看到，ConutDownLatch，Semaphore，ReentrantLock等常见的工具类都是由AQS来实现的。</p>
<h1 id="AQS基本架构"><a href="#AQS基本架构" class="headerlink" title="AQS基本架构"></a>AQS基本架构</h1><p>首先从AQS类的定义开始，逐步深入了解。AQS类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以看到AbstractQueuedSynchronizer是一个抽象类</span></span><br><span class="line"><span class="comment"> * 实现了Serializable 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The synchronization state.</span></span><br><span class="line"><span class="comment">    * state变量表示锁的状态</span></span><br><span class="line"><span class="comment">    * 0 表示未锁定</span></span><br><span class="line"><span class="comment">    * 大于0表示已锁定</span></span><br><span class="line"><span class="comment">    * 需要注意的是，这个值可以用来实现锁的【可重入性】，例如 state=3 就表示锁被同一个线程获取了3次，想要完全解锁，必须要对应的解锁3次</span></span><br><span class="line"><span class="comment">    * 同时这个变量还是用volatile关键字修饰的，保证可见性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的头节点，只能通过setHead方法修改</span></span><br><span class="line"><span class="comment">     * 如果head存在，能保证waitStatus状态不为CANCELLED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的尾结点，只能通过enq方法来添加新的等待节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractQueuedSynchronizer从名字上就可以研磨本质是一个类型（队列），其内部维护着FIFO的双向副本，也就是CLH。</p>
<blockquote>
<p>CLH（Craig，Landin和Hagersten）锁定队列</p>
</blockquote>
<p>这个类别中的每一个元素都是一个Node，所以接下来了解一下其内部类Node，内部类Node的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，因为超时或者或者被中断，节点会被设置成取消状态。被取消的节点不会参与锁竞争，状态也不会再改变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示节点处于condition队列中，正在等待被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，下一次acquireShared应该无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">   <span class="comment">// 节点的等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个condition队列等待节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前驱节点或者抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前面的基础，再来看下AQS的基本结构</p>
<p><img src="https://p3-open.byteimg.com/img/pgc-image/10478bef4ce7413684cc409f9031f86d~640x0.jpeg" alt="面试必问的AQS（AbstractQueuedSynchronizer），一次性全搞定"></p>
<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>我们都知道CountDownLatch，CyclicBarrier，信号量，ReentrantLock这些工具类中，有的只支持独占，如ReentrantLock＃lock（），有的支持共享，多个线程同时执行，如信号量。也可以看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>AQS实现了两套加锁解锁的方式，那就是<strong>独占式</strong>和<strong>共享式</strong>。我们先看下<strong>独占式</strong>的实现，独占式的实现，就从ReentrantLock＃lock（）方法开始。</p>
<h1 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock#lock"></a>ReentrantLock#lock</h1><p>该方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中sync是AbstractQueuedSynchronizer的实现，我们知道，ReentrantLock支持公平锁和非公平锁，其实现类分别是FairSync和NonfairSync，我们看看公平锁和非公平锁分别是怎么实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync 公平锁的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync 非公平锁的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，非公平锁的实现更多多了一个步骤：通过CAS的方式（compareAndSetState）尝试更改状态的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。</p>
<p><strong>这就是公平锁和非公平锁的本质区别</strong></p>
<p>从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法</p>
<h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>该方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要调用tryAcquire方法尝试获取锁，成功返回true，失败就将线程封装成Node对象，放入堆栈。</p>
<h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>tryAcquire方法在AQS中并没有直接实现，而是采用<strong>模板方法</strong>的设计模式，交给子类去实现。我们来看<strong>公平锁</strong>的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state状态，0表示未锁定，大于1表示重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 表示没有线程获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 没有比当前线程等待更久的线程了，通过CAS的方式修改state</span></span><br><span class="line">            <span class="comment">// 成功之后，设置当前拥有独占访问权的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    	<span class="comment">// 独占访问权的线程就是当前线程，重入</span></span><br><span class="line">    	<span class="comment">// 此处就是【可重入性】的实现</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 直接修改state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法就是以独占的方式获取锁，获取成功后返回true。从这个方法可以看出state变量是实现可重入性的关键。</p>
<p>非公平锁的实现方式大同小异，感兴趣的同学可以自行阅读源码。</p>
<p>acquire方法除了调用tryAcquire，还调用了acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，这里分为两步，先看下addWaiter方法。</p>
<h2 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h2><p>该方法用于把当前线程封装成一个Node节点，并加入队列。方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> * 为当前线程和给定模式创建并排队节点，给的的模式分为：</span></span><br><span class="line"><span class="comment"> * 1、Node.EXCLUSIVE：独占模式</span></span><br><span class="line"><span class="comment"> * 2、Node.SHARED：共享模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速添加尾结点，失败就执行enq方法</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS的方式设置尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速添加失败，执行该方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * 将节点插入队列，必要时进行初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 自旋</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        	<span class="comment">// 尾结点为空，队列还没有进行初始化</span></span><br><span class="line">        	<span class="comment">// 设置头节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS的方式设置尾结点，失败就进入下次循环</span></span><br><span class="line">            <span class="comment">// 也就是【自旋 + CAS】的方式保证设置成功</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法就是用来往队列尾部插入一个新的节点，通过<strong>自旋 + CAS</strong>的方式保证<strong>线程安全</strong>和<strong>插入成功</strong>。</p>
<p>需要注意的是，<strong>该方法返回的Node节点不是新插入的节点，而是新插入节点的前驱节点。</strong></p>
<h2 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h2><p>该方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 操作是否成功</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 自旋</span></span><br><span class="line">        	<span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            	<span class="comment">// 前驱节点是头节点，并且已经获取了锁（tryAcquire方法在前文中详细讲解过）</span></span><br><span class="line">            	<span class="comment">// 就把当前节点设置成头节点（因为前驱节点已经获取了锁，所以前驱节点不用再留在队列）</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果前驱节点不是头节点或者没有获取锁</span></span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire方法用于判断当前线程是否需要被阻塞</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并且检测线程是否被中断</span></span><br><span class="line">                <span class="comment">// 没抢到锁的线程需要被阻塞，避免一直去争抢锁，浪费CPU资源</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	<span class="comment">// 自旋异常退出，取消正在进行锁争抢</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h2><p>shouldParkAfterFailedAcquire方法定义如下，用于判断当前线程是否需要被阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * SIGNAL表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line"><span class="comment">         * 所以作为后继节点，node直接返回true，表示需要被阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点被取消了，需要从队列中移除，并且循环找到下一个不是取消状态的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过CAS将前驱节点的status设置成SIGNAL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h2><p>parkAndCheckInterrupt方法定义如下，用于阻塞线程并且检测线程是否被中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 阻塞当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 检测当前线程是否被中断（该方法会清除中断标识位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<strong>独占锁的整个加锁过程就已经完成</strong>。再来回顾下整个流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行tryAcquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addWaiter方法把当前线程封装成一个Node，加到队列的尾部，再通过acquireQueued方法尝试获取同步锁，成功获取锁的线程的Node节点会被移出队列。</p>
<p>如果以上条件都满足，会执行selfInterrupt方法中断当前线程。</p>
<p>看完了独占锁的加锁，再来看看独占锁的解锁。同样从ReentrantLock入手</p>
<h1 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock#unlock"></a>ReentrantLock#unlock</h1><p>方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道了sync是AQS的实现，所以直接查看AQS中的release方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    	<span class="comment">// 尝试释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 头节点已经释放，唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大家已经猜到了，和加锁时一样，这里的tryRelease方法同样使用了<strong>模板方法</strong>的设计模式，其真正的逻辑由子类实现</p>
<h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><p>方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 计算剩余的重入次数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全的释放了锁（针对可重入性）</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 表示完全释放了锁</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 设置独占锁的持有者为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置AQS的state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><p>unparkSuccessor方法用于唤醒后继节点，其定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取当前节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 当前节点的后继节点为null，或者被取消了</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        	<span class="comment">// 从尾结点查找状态不为取消的可用节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    	<span class="comment">// 唤醒后继节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文说过AQS实现了两套同步逻辑，也就是<strong>独占式</strong>和<strong>共享式</strong>。看完了独占式锁的实现，再来看一下共享式。这里以Semaphore为例。</p>
<h1 id="Semaphore-acquire"><a href="#Semaphore-acquire" class="headerlink" title="Semaphore#acquire"></a>Semaphore#acquire</h1><p>该方法是作用是请求一个许可，如果暂时没有可用的许可，则被阻塞，等待将来的某个时间被唤醒。因为Semaphore可以允许多个线程同时执行，所以可以看成是共享锁的实现。该方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync是AQS的实现，可以看到acquire方法底层调用的是acquireSharedInterruptibly方法。</p>
<p>在JDK中，与锁相关的方法，Interruptibly表示<strong>可中断</strong>，也就是<strong>可中断锁</strong>。可中断锁的意思是<strong>线程在等待获取锁的过程中可以被中断</strong>，换言之，<strong>线程在等待锁的过程中可以响应中断</strong>。</p>
<p>接下来看看acquireSharedInterruptibly方法的实现</p>
<h2 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    	<span class="comment">// 检测线程的中断中断状态，如果已经被中断了，就响应中断</span></span><br><span class="line">    	<span class="comment">// 该方法会清除线程的中断标识位</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h2><p>tryAcquireShared方法，相信大家已经能看出来，这里使用了<strong>模板方法模式</strong>，具体实现由子类去实现。Semaphore也实现了公平模式和非公平模式。公平的方式和非公平的方式实现逻辑大同小异。所以具体看下公平模式下的实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">        	<span class="comment">// 如果有线程排在自己的前面（公平锁排队），直接返回</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取同步状态的值</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 可用的（许可）减去申请的，等于剩余的</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="comment">// 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环</span></span><br><span class="line">            <span class="comment">// 如果剩余小于0，返回负数，表示失败</span></span><br><span class="line">            <span class="comment">// 如果设置状态成功，表示申请许可成功，返回正数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处还是<strong>自旋 + CAS</strong>的方式保证线程安全和设置成功。</p>
<h2 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h2><p>doAcquireSharedInterruptibly方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * 在共享可中断模式下请求（许可）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 为当前线程和给定模式创建节点并插入队列尾部，addWaiter方法前文讲解过</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 操作是否失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 自旋</span></span><br><span class="line">        	<span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            	<span class="comment">// 如果前驱节点是头节点，以共享的方式请求获取锁，tryAcquireShared方法前文讲解过</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="comment">// 成功获取锁，设置头节点和共享模式传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果前驱节点不是头节点或者没有获取锁</span></span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire方法用于判断当前线程是否需要被阻塞，该方法前文讲解过</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并且检测线程是否被中断，该方法前文讲解过</span></span><br><span class="line">                <span class="comment">// 没抢到锁的线程需要被阻塞，避免一直去争抢锁，浪费CPU资源</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	<span class="comment">// 自旋异常退出，取消正在进行锁争抢</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁的逻辑已经完成，再来看看解锁的逻辑。</p>
<h1 id="Semaphore-release"><a href="#Semaphore-release" class="headerlink" title="Semaphore#release"></a>Semaphore#release</h1><p>release用于释放许可，其方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 自旋</span></span><br><span class="line">    	<span class="comment">// 获取同步状态的值</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 可用的（许可）加上释放的，等于剩余的</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">        	<span class="comment">// CAS的方式设置同步状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到此处依旧是<strong>自旋 + CAS</strong>的操作</p>
<h2 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 自旋</span></span><br><span class="line">    	<span class="comment">// 记录头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        	<span class="comment">// 头节点不为null，且不等于尾结点，说明队列中还有节点</span></span><br><span class="line">        	<span class="comment">// 获取头节点等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            	<span class="comment">// 头节点等待状态是SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                	<span class="comment">// 如果修改节点等待状态失败，进入下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 修改成功后，唤醒后继节点，unparkSuccessor前文讲过</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS是并发编程中比较难的一个类，但是理解AQS非常重要，因为它是JDK中锁和其他同步工具实现的基础</p>
]]></content>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
</search>
