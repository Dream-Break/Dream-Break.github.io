<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CAS算法与Java原子类</title>
      <link href="/blog/2021/03/23/CAS/"/>
      <url>/blog/2021/03/23/CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>​    一般而言，在并发情况下我们必须通过一定的手段来保证数据的准确性，如果没有做好并发控制，就可能导致脏读、幻读和不可重复度等一系列问题。乐观锁是人们为了应付并发问题而提出的一种思想，具体的实现则有多种方式。</p><p>​    乐观锁假设数据一般情况下不会造成冲突，只在数据进行提交更新时，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，可以提高程序的吞吐量。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>​    CAS（Compare And Swap）比较并交换，是一种实现了乐观锁思想的并发控制技术。CAS 算法的过程是：它包含 3 个参数 CAS（V，E，N），V 表示要更新的变量（内存值），E 表示旧的预期值，N 表示即将更新的预期值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，说明已经有其他线程做了更新，则当前线程什么也不做，并返回当前 V 的真实值。整个操作是原子性的。</p><p>​    当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并允许再次尝试，当然也可以放弃本次操作，所以 CAS 算法是非阻塞的。基于上述原理，CAS 操作可以在不借助锁的情况下实现合适的并发处理。</p><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>​    ABA 问题是 CAS 算法的一个漏洞。CAS 算法实现的一个重要前提是：取出内存中某时刻的数据，并在下一时刻比较并替换，在这个时间差内可能会导致数据的变化。</p><p>​    假设有两个线程，分别要对内存中某一变量做 CAS 操作，线程一先从内存中取出值 A，线程二也从内存中取出值 A，并把值从 A 变为 B 写回，然后又把值从 B 变为 A 写回，这时候线程一进行 CAS 操作，发现内存中的值还是 A，于是认为和预期值一致，操作成功。尽管线程一的 CAS 操作成功，但并不代表这个过程就没有问题。</p><p>​    ABA 问题会带来什么隐患呢？维基百科给出了详细的示例：假设现有一个用单链表实现的堆栈，栈顶为 A，A.next = B，现有线程一希望用 CAS 把栈顶替换为 B，但在此之前，线程二介入，将 A、B 出栈，再压入 D、C、A，整个过程如下</p><p><img src="https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201023160912203-1236895465.png" alt="img"></p><p>​    此时 B 处于游离转态，轮到线程一执行 CAS 操作，发现栈顶仍为 A，CAS 成功，栈顶变为 B，但实际上 B.next = null，即堆栈中只有 B 一个元素，C 和 D 并不在堆栈中，平白无故就丢了。简单来说，ABA 问题使我们漏掉某一段时间的数据监控，谁知道在这段时间内会发生什么有趣（可怕）的事呢？</p><p>​    可以通过版本号的方式来解决 ABA 问题，每次执行数据修改操作时，都会带上一个版本号，如果版本号和数据的版本一致，对数据进行修改操作并对版本号 +1，否则执行失败。因为每次操作的版本号都会随之增加，所以不用担心出现 ABA 问题。</p><h1 id="使用Java模拟CAS算法"><a href="#使用Java模拟CAS算法" class="headerlink" title="使用Java模拟CAS算法"></a>使用Java模拟CAS算法</h1><p>这仅仅是基于 Java 层面上的模拟，真正的实现要涉及到底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 获取预估值</span></span><br><span class="line">                    <span class="keyword">int</span> expectedValue = cas.get();</span><br><span class="line">                    <span class="keyword">boolean</span> b = cas.compareAndSet(expectedValue, (<span class="keyword">int</span>) (Math.random() * <span class="number">101</span>));</span><br><span class="line">                    System.out.println(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取内存值</span></span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="comment">// 比较</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>原子包 java.util.concurrent.atomic 提供了一组原子类，原子类的操作具有原子性，一旦开始，就一直运行直到结束，中间不会有任何线程上下文切换。原子类的底层正是基于 CAS 算法实现线程安全。</p><p>Java 为我们提供了十六个原子类，可以大致分为以下四种：</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li><p>AtomicBoolean</p><p>原子更新布尔类型，内部使用 int 类型的 value 存储 1 和 0 表示 true 和 false，底层也是对 int 类型的原子操作</p></li><li><p>AtomicInteger</p><p>原子更新 int 类型</p></li><li><p>AtomicLong</p><p>原子更新 long 类型</p></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li><p>AtomicReference</p><p>原子更新引用类型，通过泛型指定要操作的类</p></li><li><p>AtomicMarkableReference</p><p>原子更新引用类型，内部维护一个 Pair 类型（静态内部类）的成员属性，其中有一个 boolean 类型的标志位，避免 ABA 问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mark;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure></li><li><p>AtomicStampedReference</p><p>原子更新引用类型，内部维护一个 Pair 类型（静态内部类）的成员属性，其中有一个 int 类型的邮戳（版本号），避免 ABA 问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><ul><li><p>AtomicIntegerArray</p><p>原子更新 int 数组中的元素</p></li><li><p>AtomicLongArray</p><p>原子更新 long 数组中的元素</p></li><li><p>AtomicReferenceArray</p><p>原子更新 Object 数组中的元素</p></li></ul><h2 id="对象属性类型"><a href="#对象属性类型" class="headerlink" title="对象属性类型"></a>对象属性类型</h2><p>用于解决对象的属性的原子操作</p><ul><li><p>AtomicIntegerFieldUpdater</p><p>原子更新对象中的 int 类型字段</p></li><li><p>AtomicLongFieldUpdater</p><p>原子更新对象中的 long 类型字段</p></li><li><p>AtomicReferenceFieldUpdater</p><p>原子更新对象中的引用类型字段</p></li></ul><p>之前提到的三种类型的使用都比较简单，查阅对应 API 即可，而对象属性类型则有一些限制：</p><ul><li>字段必须是 volatile 类型的，在线程之间共享变量时保证立即可见</li><li>只能是实例变量，不能是类变量，也就是说不能加 static 关键字</li><li>只能是可修改变量，不能使用 final 变量</li><li>该对象字段能够被直接操作，因为它是基于反射实现的</li></ul><h2 id="高性能原子类"><a href="#高性能原子类" class="headerlink" title="高性能原子类"></a>高性能原子类</h2><p>Java8 新增的原子类，使用分段的思想，把不同的线程 hash 到不同的段上去更新，最后再把这些段的值相加得到最终的值。以下四个类都继承自 Striped64，对并发的优化在 Striped64 中实现</p><p><img src="https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201023160928958-395433581.png" alt="img"></p><ul><li><p>LongAccumulator</p><p>long 类型的聚合器，需要传入一个 long 类型的二元操作，可以用来计算各种聚合操作，包括加乘等</p></li><li><p>LongAdder</p><p>long 类型的累加器，LongAccumulator 的特例，只能用来计算加法，且从 0 开始计算</p></li><li><p>DoubleAccumulator</p><p>double 类型的聚合器，需要传入一个 double 类型的二元操作，可以用来计算各种聚合操作，包括加乘等</p></li><li><p>DoubleAdder</p><p>double 类型的累加器，DoubleAccumulator 的特例，只能用来计算加法，且从 0 开始计算</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sychronized关键字</title>
      <link href="/blog/2021/03/23/sychronized/"/>
      <url>/blog/2021/03/23/sychronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized作用"><a href="#Synchronized作用" class="headerlink" title="Synchronized作用"></a>Synchronized作用</h1><ul><li><p>原子性：synchronized保证语句块内操作是原子的</p></li><li><p>可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）</p></li><li><p>有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）</p><span id="more"></span></li></ul><h1 id="Synchronized使用场景"><a href="#Synchronized使用场景" class="headerlink" title="Synchronized使用场景"></a>Synchronized使用场景</h1><p>Synchronized可以使用在方法上与代码块上，两者之间的区别为：</p><h2 id="方法上"><a href="#方法上" class="headerlink" title="方法上"></a><strong>方法上</strong></h2><p>使用在静态方法上时，Synchronized锁住的是类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用在实例方法上时，Synchronized锁住的是实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码块上"><a href="#代码块上" class="headerlink" title="代码块上"></a><strong>代码块上</strong></h2><p>在代码块中填写this，会锁住实例对象，直到执行完方法后才会释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码块中填写类名.Class会锁住该类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Test.Class)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码块中填写任意实例对象，会锁住填入的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(url)&#123;</span><br><span class="line">System.out.println(url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String myName = <span class="string">&quot;hehe&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Synchronized(myName)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;myName&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> satatic <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Synchronized&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码包含一个synchronized代码块玉一个synchronized的静态方法，将其编译后的class文件反编译后得到如下内容，注意标红处。</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h2><p><img src="https://tcs.teambition.net/storage/31234eba51099fa3374096f613c766821cf4?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM0ZWJhNTEwOTlmYTMzNzQwOTZmNjEzYzc2NjgyMWNmNCJ9.JVbkQS1NNg47vEuR0KhjRGfZWZSX6T_xpwl4x5rTwRM" alt="img"></p><p>Synchronized关键字经过javac编译后，会在同步块的前后生成monitorenter和monitorexit两个字节码指令。根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要尝试获取对象的锁（<strong>获取对象锁的过程，其实是获取monitor对象的所有权的过程</strong>）</p><p>如果这个对象没有锁定或当前线程已经持有那个对象的锁，就会把锁的计数器加一，在执行monitorexit命令时，锁计数器减一，一旦计算器为0，锁会被释放。</p><p>如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有他的线程释放。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a><strong>同步方法</strong></h2><p><img src="https://tcs.teambition.net/storage/3123a5434e73646fdd6a3582c5554f492abb?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNhNTQzNGU3MzY0NmZkZDZhMzU4MmM1NTU0ZjQ5MmFiYiJ9.rJzTkMi0uW5aNtZSky5Y6FwRaDewDtNKB_dUjhdQJXU" alt="img"></p><p>注意红框标注的ACC_SYNCHRONIZED标志，当线程执行方法时会检测是否存在这个标志，如果存在会隐式调用monitorenter与monitorexit命令将方法锁住。</p><h1 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h1><p>在前面说过，获取对象锁的过程就是获取monitor对象的所有权，哪个对象持有了monitor对象，那个线程就获得了锁，获得锁后可以重复获取monitor对象，但同一个线程每获取一次monitor对象，锁计数器就会加一，在解锁的时候就需要将计算器减为0才会释放。monitor对象在反编译代码中并不显示，这个对象存放在对象头中。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><strong>对象头</strong></h2><p>在HotSpot虚拟机中，对象在堆内存的存储布局为：对象头（Header）、实例数据（InstanceData）、对齐填充（Padding）</p><p>实例数据中存储的是对象的真正有效数据，里面包含各种类型的字段内容，无论是本身的还是继承的。</p><p>对齐填充非必须存在，只是为了占位，虚拟机自动管理内存系统要求对象的大小必须是8的整倍数，当对象大小不足时，会用对齐填充补齐。</p><p>对象头包含两部分信息：</p><p>1、自身运行时数据：hashcode、GC分代年龄、<strong>锁状态标志</strong>、<strong>线程持有的锁</strong>、<strong>偏向线程ID</strong>等，这部分数据官方名为“<strong>Mark Word</strong>”</p><p>2、类型指针，即对象指向它的类型元数据的指针，虚拟机通过它来确定对象是哪个类型的实例。</p><p>3、如果是数组对象，会存储数组长度。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>虚拟机位数</td><td>对象头结构</td><td>描述</td></tr><tr><td>32位/64位</td><td>Mark Word</td><td>存储对象的哈希码、GC分代年龄、锁信息等</td></tr><tr><td>32位/64位</td><td>Class MetaData Address</td><td>指向对象类型数据的指针</td></tr><tr><td>32位/64位</td><td>数组长度</td><td>如果是数组对象的话，有这一部分，否则没有</td></tr></tbody></table><p>接着回到我们的monitor对象，monitor对象的源码是C++写的，在虚拟机的ObjectMonitor.hpp文件中。数据结构长这个样子。</p><p><img src="https://tcs.teambition.net/storage/3123387c9b51a96c5981a4b651c343138683?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjMzODdjOWI1MWE5NmM1OTgxYTRiNjUxYzM0MzEzODY4MyJ9.-FOyDRaBzr2hcNKOHdg9GXaRW_yn4G7qMlr0TbYdHZc" alt="img"></p><p>有想对这个monitor对象更深入了解的可以去Java虚拟机的源码里看看。</p><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>在主流的Java虚拟机实现中，Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一条线程，则需要操作系统配合，这就不可避免地陷入用户态与核心态的转换中，这种状态的转换非常耗时，所以在ObjectMonitor文件中的调用过程和复杂的操作系统运行机制导致线程的阻塞或唤醒时是很耗费资源的。这样在JDK1.6之前都称synchronized为重量级锁。</p><h2 id="重量级锁的减轻"><a href="#重量级锁的减轻" class="headerlink" title="重量级锁的减轻"></a><strong>重量级锁的减轻</strong></h2><p>高效并发是从JDK5到JDK6的一项重要改进，synchronized在升级后的整个加锁过程，大致如下图。</p><p><img src="https://tcs.teambition.net/storage/3123dfb4a69bbe5bf80415278f02848fbf27?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNkZmI0YTY5YmJlNWJmODA0MTUyNzhmMDI4NDhmYmYyNyJ9.AziU5OTXD788NSeoWSUMLZTq17S7XB2eUr2n8QJzTv8" alt="img"></p><p>注：<strong>锁升级的过程不可逆</strong></p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h2><p>上方对头中说明存在一个偏向锁的线程ID，其含义为：如果一个线程获得锁后，锁的计数器就会加一，并且将这个线程的id存入锁住的这个对象的对象头中。</p><p>这个过程是通过CAS来实现的，每次线程进入都是无锁的，当执行CAS成功后，直接将锁的计数器加一（持有偏向锁的线程以后每次进入锁时不做任何操作，计数器直接加一），这个时候其他现场再进来时，执行CAS就会失败，即获取锁失败。</p><p><img src="https://tcs.teambition.net/storage/312353a8974ae1480a745dd6d8524949ccf3?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM1M2E4OTc0YWUxNDgwYTc0NWRkNmQ4NTI0OTQ5Y2NmMyJ9.tzORXP7GN-iRP-ET9QFFwMQwwzVrO7MxNDb3ujATaz4" alt="img"></p><p>偏向锁在JDK1.6是默认开启的，通过参数进行关闭：xx:-UseBiasedLocking=false。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但如果大多数的锁都被多个不同的线程访问，那偏向锁就是多余的。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁与对象头的第一部分有关。</p><p>在代码即将进入代码块时，如果此同步对象没有被锁定，虚拟机首先将当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</p><p>然后JVM将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果这个更新动作成功了，说明线程获取锁成功，并执行后面的同步操作。如果这个更新动作失败了，说明锁对象已经被其他线程抢占了，那轻量级锁不在有效，必须膨胀为重量级锁。此时被锁住的对象标志变为重量级锁的标志。</p><p><img src="https://tcs.teambition.net/storage/312348932a4ddf20a9f633ebe165c40c7e75?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM0ODkzMmE0ZGRmMjBhOWY2MzNlYmUxNjVjNDBjN2U3NSJ9.rmcetSzA6nJovoHS24jX1OoOKKQW87ESP1NZ8fOmAis" alt="img"></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当轻量级锁获取失败后，就会升级为重量级锁，但是重量级锁是很费资源的，JVM团队注意到许多程序上，共享数据的二锁定状态之后持续很短一段时间，为了这段时间去挂起与恢复线程并不值得，<strong>所以想到了一个策略，那就是当线程请求一个已经被锁住的对象时，可以让未获取锁的线程“稍等一会”，但不放弃处理器执行时间，只需要让线程执行一个忙循环（自旋），这就是所谓的自旋锁。</strong>自旋锁在JDK1.4.2中引入，默认关闭，可以通过-XX:UserSpinning参数来开启，默认自旋次数是10次，用户可以自定义次数，配置参数是-XX:PreBockSpin。</p><p>无论是用户指定还是默认值的自旋次数，对JVM重所有的锁来说都是相同的。在JDK6中引入了自适应自旋，根据前一次在同一锁上的自旋时间及拥有者的状态来决定。如果上一次同一个对象自旋锁获得成功了，那么再次进行自旋时就会认为成功几率很大，那么自旋次数就会自动增加。反之如果自旋很少成功获得锁，那么以后这个自旋过程都有可能被省略掉。</p><p>这样在轻量级失败后，就会升级为自旋锁，如果自旋锁也失败了，那就只能是升级到重量级锁了。</p><p><img src="https://tcs.teambition.net/storage/31232ab971bc41c6d7fbf164782dad8cf67a?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTMxMCwiaWF0IjoxNjE2NDcwNTEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjMyYWI5NzFiYzQxYzZkN2ZiZjE2NDc4MmRhZDhjZjY3YSJ9.0p_zMSTKi3V2SM4gwXZRbVfHNHdlHdiavjvu3bmqAOA" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Synchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。主要步骤是：</p><ol><li>先是通过偏向锁来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。</li><li>再是通过对象头的Mark Word来实现的轻量级锁，通过轻量级锁如果还有竞争，那么继续升级。</li><li>升级为自旋锁，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="/blog/2021/03/23/volatile/"/>
      <url>/blog/2021/03/23/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在面试中，对于多线程经常会用到volatile关键字，关于volatile，大多人只知道它可以<strong>保持可见性、禁止指令重排序</strong>，但再往深问，具体是如何实现的，在什么场景下使用，为什么不直接使用synchronized关键字。</p><span id="more"></span><h1 id="系统处理效率与Java内存模型"><a href="#系统处理效率与Java内存模型" class="headerlink" title="系统处理效率与Java内存模型"></a>系统处理效率与Java内存模型</h1><p>在计算机中，每条程序指令都是在CPU中执行的，而CPU执行指令的数据都是临时存储在内存中的，但是CPU的读取速度远超内存的读取速度，如果所有的CPU指令都从内存读取会大大降低效率，<strong>所有现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器的高速缓存（Cache）来作为处理器与内存中间的缓冲。</strong></p><p>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后，再从缓存同步到内存中，这样处理器就无需等待缓慢的内存读写了。</p><p>虽然增加了高速缓冲提升了处理器的处理效率，但也带来了新的问题：</p><p>现代计算机都是多核CPU，一开始，内存中的变量A的值是1，第一个CPU读取了数据，第二个CPU也将数据读取到了自己的高速缓存当中，当第一个CPU对变量A进行加1操作时，变量A的值变成了2，然后将将变量A的值写回内存中，这时第二个CPU也对变量A进行加1操作时，由于第二个CPU中高速缓存中的值还是1，所以加1操作后的结果为2，然后第二个CPU又将变量A的值同步回内存中，这样就导致执行了两次加1操作后，变量A的值最终是2，而不是3。<strong>这种被多个CPU访问的变量，通常称为共享变量。</strong>而产生的上面的问题，就是引入了高速缓存后的，主内存和缓存内容不一致的问题。因为每个处理器有自己的高速缓存，但是它们又共享同一块主内存，所以必然会出现主内存不知该以哪个高速缓存中的变量为准的情况。</p><p><img src="https://tcs.teambition.net/storage/3123a66b1b8f83d6bf3b1fd3b27235a1425e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNhNjZiMWI4ZjgzZDZiZjNiMWZkM2IyNzIzNWExNDI1ZSJ9.a1RIrZ4CNkdkqFYvKgkkTYLhbqq7HGao9YpIoCfTMzQ" alt="img"></p><p>上面这个缓存不一致的问题，我们先记下来，继续来看Java内存模型，其实Java内存模型描述的上面讲的计算机系统高速缓存和内存之间的关系类似。</p><p>Java内存模型描述了，<strong>各种变量的访问规则，以及将变量存储到内存和从内存读取变量的这种底层细节。</strong></p><p>在Java内存模型中关注的变量都是共享变量（实例变量、类变量）。所有的共享变量都是存储在<strong>主内存</strong>中的，但是每个线程在访问变量的时候也都会在自己的<strong>工作内存</strong>（<strong>处理器高速缓存</strong>）中保留一份共享变量的副本。</p><h1 id="Java内存模型（Java-Memory-Model，简称JMM）"><a href="#Java内存模型（Java-Memory-Model，简称JMM）" class="headerlink" title="Java内存模型（Java Memory Model，简称JMM）"></a>Java内存模型（Java Memory Model，简称JMM）</h1><p>线程对变量的所有操作（读，写）都必须在工作内存中进行，不能直接操作主内存中的数据。不同线程之间 也不能直接访问对方工作内存中的变量，线程间的变量值传递必须通过主内存进行中转传递。在JMM中工作内存和主内存的关系如下图：<img src="https://tcs.teambition.net/storage/312375a3cc8f7a30abe4a28da0e641ca6e87?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM3NWEzY2M4ZjdhMzBhYmU0YTI4ZGEwZTY0MWNhNmU4NyJ9.oAl0IadzNbAwYxpnCZMMS4lXPIKe0ZeU0sbZC0jui_0" alt="img"></p><h1 id="Volatile可见性"><a href="#Volatile可见性" class="headerlink" title="Volatile可见性"></a>Volatile可见性</h1><p>继续我们上面的缓存一致性的问题，这个问题，在Java内存模型中，就是可见性的问题，即一个线程修改了共享变量的值，对另一个线程来说是不是立即可见的。如果不是立即可见的，那么就会出现缓存一致性的问题，如果是立即可见的，那么另一个线程在进行操作的时候，拿到的变量值就是最新的。就可以解决可见性的问题。</p><h1 id="如何解决可见性问题"><a href="#如何解决可见性问题" class="headerlink" title="如何解决可见性问题"></a>如何解决可见性问题</h1><h2 id="方案一：加锁"><a href="#方案一：加锁" class="headerlink" title="方案一：加锁"></a>方案一：加锁</h2><p>将共享变量加锁，无论是synchronized还是Lock都可以，加锁达到的目的是在同一时间内只能有一个线程能对共享变量进行操作，就是说，共享变量从读取到工作内存到更新值后，同步回主内存的过程中，其他线程是操作不了这个变量的。这样自然就解决了可见性的问题了，但是这样的效率比较低，操作不了共享变量的线程就只能阻塞。</p><h2 id="方案二：使用Voaltile修饰共享变量"><a href="#方案二：使用Voaltile修饰共享变量" class="headerlink" title="方案二：使用Voaltile修饰共享变量"></a>方案二：使用Voaltile修饰共享变量</h2><p>当一个共享变量被volatile修饰后，会保证每个线程将变量修改后的值立即同步回主内存中，当其他线程有需要读取变量时会读取到最新的变量值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被volatile修饰的变量，在被线程操作时，会有这样的机制</span><br></pre></td></tr></table></figure><p>就是线程对变量操作时会从主内存中读取到自己的工作内存中，当线程对变量进行了修改后，那么其他已经读取了此变量的线程中的变量副本就会失效，这样其他线程在使用变量的时候，发现已经失效，那么就会去主内存中重新获取，这样获取到的就只最新的值了。</p><h3 id="volatile具体如何实现"><a href="#volatile具体如何实现" class="headerlink" title="volatile具体如何实现"></a>volatile具体如何实现</h3><p>因为一台计算机有多台CPU，同一个变量，在多个CPU中缓存的值有可能不一样，那么以谁缓存的值为准呢？</p><p>既然大家都有自己的值，那么各个CPU间就产生了一种协议，来保证按照一定的规律为准，来确定共享变量的准确值，这样各个CPU在读写共享变量时都按照协议来操作。</p><p>这就是缓存一致性协议。</p><p>最著名的缓存一致性协议就是Intel的MESI了，说MESI时，先解释一下，缓存行：</p><blockquote><p>缓存行（cache line）：CPU高速缓存的中可以分配的最小存储单位，高速缓存中的变量都是存在缓存行中的。</p></blockquote><p><strong>MESI的核心思想就是，当CPU对变量进行写操作时发现，变量是共享变量，那么就会通知其他CPU中将该变量的缓存行设置为无效状态。当其他CPU在操作变量时发现此变量在的缓存行已经无效，那么就会去主内存中重新读取最新的变量。</strong></p><ul><li><strong>那么其他CPU是如何发现变量被修改了的呢？</strong></li></ul><p>因为CPU和其他部件的进行通信是通过总线来进行的，所以每个CPU通过嗅探总线上的传播数据，来检查自己缓存的值是不是过期了，当处理器发现自己换成行对应的内存地址被修改后，就会将自己工作内存中的缓存行设置成无效状态，当CPU对此变量进行修改时会重新从系统主内存中读取变量。</p><p><img src="https://tcs.teambition.net/storage/31239bb8c904d50a5b5d0c8667124423014e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM5YmI4YzkwNGQ1MGE1YjVkMGM4NjY3MTI0NDIzMDE0ZSJ9.JT0aUDnk_3LNbi2Mh3i5gCHqceGWqlfqDDnIFLjM1Yc" alt="img"></p><h2 id="Volatile的有序性（禁止指令重排序）"><a href="#Volatile的有序性（禁止指令重排序）" class="headerlink" title="Volatile的有序性（禁止指令重排序）"></a>Volatile的有序性（禁止指令重排序）</h2><p>一般来说，我们写程序的时候，都是要把先代码从上往下写，默认的认为程序是自顶向下顺序执行的，但是CPU为了提高效率，在保证最终结果准确的情况下，是会对指令进行重新排序的。就是说写在前的代码不一定先执行，在后面的也不一定晚执行。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// 代码1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>; <span class="comment">// 代码2</span></span><br><span class="line">a = a + <span class="number">4</span>;<span class="comment">// 代码3</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;<span class="comment">// 代码4</span></span><br></pre></td></tr></table></figure><p>上面四行代码的执行顺序有可能是</p><p><img src="https://tcs.teambition.net/storage/3123f5ae619cf8291596ac325cd1e6b4f9c5?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNmNWFlNjE5Y2Y4MjkxNTk2YWMzMjVjZDFlNmI0ZjljNSJ9.p6R_JBUFRFUQp8B4fJySDu5PLLOrXGCQLNzwOduFn5g" alt="img"></p><p>JMM在是允许指令重排序的，在保证最后结果正确的情况下，处理器可以尽情地发挥，提高执行效率。</p><p>当多个线程执行代码的时候重排序的情况就更为突出了，各个CPU为了提高自己的效率，有可能会产生竞争情况，这样就有可能导致最终执行的正确性。</p><p>所以为了保证在多个线程下最终执行的正确性，将变量用volatile进行修饰，这样就会达到禁止指令重排序的效果（其实也可以通过加锁，还有一些其他已知规则来实现禁止指令重排序，但是我们这里只讨论volatile的实现方式）。</p><h3 id="volatile如何实现指令重排序"><a href="#volatile如何实现指令重排序" class="headerlink" title="volatile如何实现指令重排序"></a>volatile如何实现指令重排序</h3><p>答案是：<strong>内存屏障</strong></p><p><strong>内存屏障</strong>是一组CPU指令，用于实现对内存操作的顺序限制。Java编译器，会在生成指令系列时，在适当的位置会插入内存屏障来禁止处理器对指令的重新排序。</p><p>volatile会在变量写操作的前后加入两个内存屏障，来保证前面的写指令和后面的读指令是有序的。</p><p><img src="https://tcs.teambition.net/storage/31231da51999ef7656daac49d517673bfc93?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjMxZGE1MTk5OWVmNzY1NmRhYWM0OWQ1MTc2NzNiZmM5MyJ9.fIwp50xili2EKHnJF9pUgU7hipgkCZTgjQwyJmdST3M" alt="img"></p><p>volatile在变量的读操作后面插入两个指令，禁止后面的读指令和写指令重排序。</p><p><img src="https://tcs.teambition.net/storage/3123c3ac08c811b3b0b1a891612ae1a819f0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzA3NTA4NywiaWF0IjoxNjE2NDcwMjg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNjM2FjMDhjODExYjNiMGIxYTg5MTYxMmFlMWE4MTlmMCJ9.MJD52pSnTyKeqieAeHPqxBUINqo1Rnk3wDKTApNCcMk" alt="img"></p><p>有序性，不仅只有volatile能保证，其他的实现方式也能保证，但是如果每一种实现方式都要了解那对于开发人员来说就比较困难了。</p><p><strong>所以从JDK5就出现了happen-before原则，也叫先行发生原则。</strong>先行发生原则总结起来就是：<strong>如果一个操作A的产生的影响能被另一个操作B观察到，那么可以说，这个操作A先行发生与操作B。</strong></p><p>这里所说的影响包括内存中的变量的修改，调用了方法，发送量消息等。</p><p><strong>volatile中的先行发生原则是，对一个<strong><strong>volatile</strong></strong>变量的写操作，先行发生于后面任何地方对这个变量的读操作。</strong></p><h1 id="Volatile无法保证原子性"><a href="#Volatile无法保证原子性" class="headerlink" title="Volatile无法保证原子性"></a><strong>Volatile无法保证原子性</strong></h1><p>原子性，是指一个操作过程要么都成功，要么都失败，是一个独立的完整的。</p><p>就像上面说的，如果多个线程对一个变量进行累加，那么肯定得不到想要的结果，因为累加就不是一个原子操作。</p><p>要保证累加最终结果正确，要么对累加变量加锁，要么就用AotomicInteger这样的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查加锁式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLockSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量，用来存放实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLockSingleton doubleCheckLockSingleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，禁止外部创建实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检查加锁的方式保证线程安全又能获得到唯一实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次检查实例是否已经存在，不存在则进入代码块</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == doubleCheckLockSingleton)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLockSingleton.class)&#123;</span><br><span class="line">                <span class="comment">//第二次检查</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>==doubleCheckLockSingleton)&#123;</span><br><span class="line">                    doubleCheckLockSingleton = <span class="keyword">new</span> DoubleCheckLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doubleCheckLockSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要进行双重检查呢？当第一个线程走到第一次检查时发现对象为空，然后进入锁，第二次就检查时也为空，那么就去创建对象，但是这个时候又来了一个线程来到了第一次检查，发现为空，但是这个时候因为锁被占用，所以就只能阻塞等待，然后第一个线程创建对象成功了，由于对象是被volatile修饰的能够立即反馈到其他线程上，所以在第一个线程释放锁之后，第二个线程进入了锁，然后进行第二次检查时，发现对象已经被创建了，那么就不在创建对象了。从而保证的单例。</p><p>还有就是如果创建对象，步骤：</p><ol><li>分配内存空间。</li><li>调用构造器，实例化。</li><li>返回内存地址给引用。</li></ol><p>如果这三个指令顺序被重排了，那么当多线程来获取对象的时候就会造成对象虽然实例化了，但是没有分配内存空间，会有空指针的风险。所以加上了volatile的对象，也保证了在第二次检查时不会被已经在创建过程中的对象有被检测为空的风险。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>volatile可以看做轻量级的synchronized，虽然volatile无法保证原子性，但是如果在多线程下的操作本身就是原子性操作（例如赋值操作），那么使用volatile会优于synchronized。</p><p>volatile可以适用于某个标志的flag，一旦被修改就需要被其他线程立即可见，可以修饰为触发器的变量，一旦变量被修改就触发某种操作。</p><p>volatile变量的写操作由于happen-before原则，一定会发生在读之前。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList解析</title>
      <link href="/blog/2021/03/22/ArrayList/"/>
      <url>/blog/2021/03/22/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><h2 id="ArrayList类图"><a href="#ArrayList类图" class="headerlink" title="ArrayList类图"></a>ArrayList类图</h2><p><img src="https://tcs.teambition.net/storage/31239f334b168e4eebefcd7c3a1b6906b9be?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzAyMDgzOSwiaWF0IjoxNjE2NDE2MDM5LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjM5ZjMzNGIxNjhlNGVlYmVmY2Q3YzNhMWI2OTA2YjliZSJ9.uKhfZBuclOWsNPt_rj83943kz4ktgycaqlkRUagsLqE" alt="img"></p><p>ArrayList的底层是由数组实现的，数组的特点是固定大小，而ArrayList实现了动态扩容。</p><span id="more"></span><p>ArrayList部分变量如下，在下面的分析中会用到这些变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空的对象数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造器创建的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的数组的缓存变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="一、初始化ArrayList"><a href="#一、初始化ArrayList" class="headerlink" title="一、初始化ArrayList"></a>一、初始化ArrayList</h2><p>初始化ArrayList一般会使用以下两个构造器</p><h3 id="1-1-无参构造器"><a href="#1-1-无参构造器" class="headerlink" title="1.1 无参构造器"></a>1.1 无参构造器</h3><p>初始化ArrayList的时候如果不指定大小，则会创建一个空数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-指定数组大小的构造器"><a href="#1-2-指定数组大小的构造器" class="headerlink" title="1.2 指定数组大小的构造器"></a>1.2 指定数组大小的构造器</h3><p>创建一个<strong>预估</strong>大小的数组，指定大小后只是指定了数组初始值的大小，不影响后面扩容，指定的好处就是可以节省内存及时间上的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、添加元素、动态扩容"><a href="#二、添加元素、动态扩容" class="headerlink" title="二、添加元素、动态扩容"></a>二、添加元素、动态扩容</h2><p>ArrayList.add(E e)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add()中elementData[size++] = e很好理解，就是将元素插入第size个位置，然后将size++，我们重点来看看ensureCapacityInternal(size + 1)方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacityInternal()方法中判断缓存变量elementData是否为空，也就是判断是否是第一次添加元素，如果是第一次添加元素，则设置初始化大小为默认容量10，否则为传入的参数。这个方法的目的就是<strong>获取初始化数组容量</strong>。获取到初始化容量后调用ensureExplicitCapacity(minCapacity)方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;// 数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容大小为原来数组长度的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 扩容容量比需要扩容的长度小，则使用需要扩容的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 扩容容量比最大数组长度大，则使用最大整数长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureExplicitCapacity(minCapacity)方法用来判断是否需要扩容，假如第一次添加元素，minCapacity为10，elementData容量为0，那么就需要去扩容。调用grow(minCapacity)方法。</p><p>grow(minCapacity)方法对数组进行扩容，扩容大小为原数组的1.5倍，如果计算出的扩容容量比需要的容量小，则扩容大小为需要的容量，如果扩容容量比数组最大容量大，则调用hugeCapacity(minCapacity)方法，将数组扩容为整数的最大长度，然后将elemetData数组指向新扩容的内存空间并将元素复制到新空间。</p><p>当需要的集合容量特别大时，扩容1.5倍就会非常消耗空间，因此建议初始化时预估一个容量大小。</p><h2 id="三、删除元素"><a href="#三、删除元素" class="headerlink" title="三、删除元素"></a>三、删除元素</h2><p>ArrayList提供两种删除元素的方法，可以通过索引和元素进行删除。两种删除大同小异，删除元素后，将后面的元素一次向前移动。</p><p>ArrayList.remove(int index)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检测下标是否属于当前对象范围，如果不属于抛出异常，属于不做任何操作</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line"><span class="comment">//获取当前下标中的旧值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"><span class="comment">//numMoved为当前对象的大小减去当前下标再减去一</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素时，首先会判断索引是否大于ArrayList的大小，如果索引范围正确，则将索引位置的下一个元素赋值到索引位置，将ArrayList的大小-1，最后返回移除的元素。操作图如下，假如我要移除索引为1的元素：</p><p><img src="https://tcs.teambition.net/storage/3123fab24eb55ab5dfa4d000988792da8c1f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTYxNzAyMDgzOSwiaWF0IjoxNjE2NDE2MDM5LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMjNmYWIyNGViNTVhYjVkZmE0ZDAwMDk4ODc5MmRhOGMxZiJ9.VMGyd0Y_z0atI1vcxfQ4ShQVmvW6MdC692coFMVOTp4" alt="img"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>ArrayList底层是数组实现的，可以进行动态扩容，扩容大小为原来的1.5倍，虽然可以通过动态扩容，但是数组非常大时会特别浪费空间，因此建议初始化时预估数组大小。ArrayList允许插入重复值和空值。ArrayList实现了RandomAccess接口，支持快速随机访问，就是可以通过索引快速查到某个元素，因此遍历时使用for循环的方式效率更高。ArrayList是线程不安全的，可以通过Collections.synchronizedList将其转变为线程安全的集合，不过一般不会使用，Vector和CopyOnWriteArrayList是线程安全的，Vector性能一般，逐渐被CopyOnWriteArrayList取代了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS详解</title>
      <link href="/blog/2021/03/21/AbstractQueuedSynchronizer/"/>
      <url>/blog/2021/03/21/AbstractQueuedSynchronizer/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>AQS是AbstractQueuedSychronizer类的简称，虽然我们不会直接使用这个类，但是这个类是Java很多并发工具的实现。</p><span id="more"></span><h1 id="实现AQS的类"><a href="#实现AQS的类" class="headerlink" title="实现AQS的类"></a>实现AQS的类</h1><p>使用IDEA可以看到，以下类是使用AQS实现的：</p><p><img src="https://p3-open.byteimg.com/img/pgc-image/d16a2a71abe644a0b7faec84c6f91565~640x0.jpeg" alt="面试必问的AQS（AbstractQueuedSynchronizer），一次性全搞定"></p><p>可以看到，ConutDownLatch，Semaphore，ReentrantLock等常见的工具类都是由AQS来实现的。</p><h1 id="AQS基本架构"><a href="#AQS基本架构" class="headerlink" title="AQS基本架构"></a>AQS基本架构</h1><p>首先从AQS类的定义开始，逐步深入了解。AQS类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以看到AbstractQueuedSynchronizer是一个抽象类</span></span><br><span class="line"><span class="comment"> * 实现了Serializable 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The synchronization state.</span></span><br><span class="line"><span class="comment">    * state变量表示锁的状态</span></span><br><span class="line"><span class="comment">    * 0 表示未锁定</span></span><br><span class="line"><span class="comment">    * 大于0表示已锁定</span></span><br><span class="line"><span class="comment">    * 需要注意的是，这个值可以用来实现锁的【可重入性】，例如 state=3 就表示锁被同一个线程获取了3次，想要完全解锁，必须要对应的解锁3次</span></span><br><span class="line"><span class="comment">    * 同时这个变量还是用volatile关键字修饰的，保证可见性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的头节点，只能通过setHead方法修改</span></span><br><span class="line"><span class="comment">     * 如果head存在，能保证waitStatus状态不为CANCELLED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的尾结点，只能通过enq方法来添加新的等待节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer从名字上就可以研磨本质是一个类型（队列），其内部维护着FIFO的双向副本，也就是CLH。</p><blockquote><p>CLH（Craig，Landin和Hagersten）锁定队列</p></blockquote><p>这个类别中的每一个元素都是一个Node，所以接下来了解一下其内部类Node，内部类Node的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，因为超时或者或者被中断，节点会被设置成取消状态。被取消的节点不会参与锁竞争，状态也不会再改变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示节点处于condition队列中，正在等待被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，下一次acquireShared应该无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">   <span class="comment">// 节点的等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个condition队列等待节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前驱节点或者抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的基础，再来看下AQS的基本结构</p><p><img src="https://p3-open.byteimg.com/img/pgc-image/10478bef4ce7413684cc409f9031f86d~640x0.jpeg" alt="面试必问的AQS（AbstractQueuedSynchronizer），一次性全搞定"></p><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>我们都知道CountDownLatch，CyclicBarrier，信号量，ReentrantLock这些工具类中，有的只支持独占，如ReentrantLock＃lock（），有的支持共享，多个线程同时执行，如信号量。也可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>AQS实现了两套加锁解锁的方式，那就是<strong>独占式</strong>和<strong>共享式</strong>。我们先看下<strong>独占式</strong>的实现，独占式的实现，就从ReentrantLock＃lock（）方法开始。</p><h1 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock#lock"></a>ReentrantLock#lock</h1><p>该方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中sync是AbstractQueuedSynchronizer的实现，我们知道，ReentrantLock支持公平锁和非公平锁，其实现类分别是FairSync和NonfairSync，我们看看公平锁和非公平锁分别是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FairSync 公平锁的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync 非公平锁的实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非公平锁的实现更多多了一个步骤：通过CAS的方式（compareAndSetState）尝试更改状态的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。</p><p><strong>这就是公平锁和非公平锁的本质区别</strong></p><p>从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法</p><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>该方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要调用tryAcquire方法尝试获取锁，成功返回true，失败就将线程封装成Node对象，放入堆栈。</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>tryAcquire方法在AQS中并没有直接实现，而是采用<strong>模板方法</strong>的设计模式，交给子类去实现。我们来看<strong>公平锁</strong>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state状态，0表示未锁定，大于1表示重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示没有线程获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 没有比当前线程等待更久的线程了，通过CAS的方式修改state</span></span><br><span class="line">            <span class="comment">// 成功之后，设置当前拥有独占访问权的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 独占访问权的线程就是当前线程，重入</span></span><br><span class="line">    <span class="comment">// 此处就是【可重入性】的实现</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 直接修改state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法就是以独占的方式获取锁，获取成功后返回true。从这个方法可以看出state变量是实现可重入性的关键。</p><p>非公平锁的实现方式大同小异，感兴趣的同学可以自行阅读源码。</p><p>acquire方法除了调用tryAcquire，还调用了acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，这里分为两步，先看下addWaiter方法。</p><h2 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h2><p>该方法用于把当前线程封装成一个Node节点，并加入队列。方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> * 为当前线程和给定模式创建并排队节点，给的的模式分为：</span></span><br><span class="line"><span class="comment"> * 1、Node.EXCLUSIVE：独占模式</span></span><br><span class="line"><span class="comment"> * 2、Node.SHARED：共享模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速添加尾结点，失败就执行enq方法</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS的方式设置尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速添加失败，执行该方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * 将节点插入队列，必要时进行初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        <span class="comment">// 尾结点为空，队列还没有进行初始化</span></span><br><span class="line">        <span class="comment">// 设置头节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS的方式设置尾结点，失败就进入下次循环</span></span><br><span class="line">            <span class="comment">// 也就是【自旋 + CAS】的方式保证设置成功</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法就是用来往队列尾部插入一个新的节点，通过<strong>自旋 + CAS</strong>的方式保证<strong>线程安全</strong>和<strong>插入成功</strong>。</p><p>需要注意的是，<strong>该方法返回的Node节点不是新插入的节点，而是新插入节点的前驱节点。</strong></p><h2 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h2><p>该方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作是否成功</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点是头节点，并且已经获取了锁（tryAcquire方法在前文中详细讲解过）</span></span><br><span class="line">            <span class="comment">// 就把当前节点设置成头节点（因为前驱节点已经获取了锁，所以前驱节点不用再留在队列）</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果前驱节点不是头节点或者没有获取锁</span></span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire方法用于判断当前线程是否需要被阻塞</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并且检测线程是否被中断</span></span><br><span class="line">                <span class="comment">// 没抢到锁的线程需要被阻塞，避免一直去争抢锁，浪费CPU资源</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        <span class="comment">// 自旋异常退出，取消正在进行锁争抢</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h2><p>shouldParkAfterFailedAcquire方法定义如下，用于判断当前线程是否需要被阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * SIGNAL表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line"><span class="comment">         * 所以作为后继节点，node直接返回true，表示需要被阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点被取消了，需要从队列中移除，并且循环找到下一个不是取消状态的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过CAS将前驱节点的status设置成SIGNAL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h2><p>parkAndCheckInterrupt方法定义如下，用于阻塞线程并且检测线程是否被中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 阻塞当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 检测当前线程是否被中断（该方法会清除中断标识位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<strong>独占锁的整个加锁过程就已经完成</strong>。再来回顾下整个流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行tryAcquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addWaiter方法把当前线程封装成一个Node，加到队列的尾部，再通过acquireQueued方法尝试获取同步锁，成功获取锁的线程的Node节点会被移出队列。</p><p>如果以上条件都满足，会执行selfInterrupt方法中断当前线程。</p><p>看完了独占锁的加锁，再来看看独占锁的解锁。同样从ReentrantLock入手</p><h1 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock#unlock"></a>ReentrantLock#unlock</h1><p>方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道了sync是AQS的实现，所以直接查看AQS中的release方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 头节点已经释放，唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家已经猜到了，和加锁时一样，这里的tryRelease方法同样使用了<strong>模板方法</strong>的设计模式，其真正的逻辑由子类实现</p><h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><p>方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算剩余的重入次数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全的释放了锁（针对可重入性）</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示完全释放了锁</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 设置独占锁的持有者为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置AQS的state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><p>unparkSuccessor方法用于唤醒后继节点，其定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取当前节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前节点的后继节点为null，或者被取消了</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        <span class="comment">// 从尾结点查找状态不为取消的可用节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文说过AQS实现了两套同步逻辑，也就是<strong>独占式</strong>和<strong>共享式</strong>。看完了独占式锁的实现，再来看一下共享式。这里以Semaphore为例。</p><h1 id="Semaphore-acquire"><a href="#Semaphore-acquire" class="headerlink" title="Semaphore#acquire"></a>Semaphore#acquire</h1><p>该方法是作用是请求一个许可，如果暂时没有可用的许可，则被阻塞，等待将来的某个时间被唤醒。因为Semaphore可以允许多个线程同时执行，所以可以看成是共享锁的实现。该方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是AQS的实现，可以看到acquire方法底层调用的是acquireSharedInterruptibly方法。</p><p>在JDK中，与锁相关的方法，Interruptibly表示<strong>可中断</strong>，也就是<strong>可中断锁</strong>。可中断锁的意思是<strong>线程在等待获取锁的过程中可以被中断</strong>，换言之，<strong>线程在等待锁的过程中可以响应中断</strong>。</p><p>接下来看看acquireSharedInterruptibly方法的实现</p><h2 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="comment">// 检测线程的中断中断状态，如果已经被中断了，就响应中断</span></span><br><span class="line">    <span class="comment">// 该方法会清除线程的中断标识位</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h2><p>tryAcquireShared方法，相信大家已经能看出来，这里使用了<strong>模板方法模式</strong>，具体实现由子类去实现。Semaphore也实现了公平模式和非公平模式。公平的方式和非公平的方式实现逻辑大同小异。所以具体看下公平模式下的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">        <span class="comment">// 如果有线程排在自己的前面（公平锁排队），直接返回</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取同步状态的值</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 可用的（许可）减去申请的，等于剩余的</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="comment">// 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环</span></span><br><span class="line">            <span class="comment">// 如果剩余小于0，返回负数，表示失败</span></span><br><span class="line">            <span class="comment">// 如果设置状态成功，表示申请许可成功，返回正数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处还是<strong>自旋 + CAS</strong>的方式保证线程安全和设置成功。</p><h2 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h2><p>doAcquireSharedInterruptibly方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * 在共享可中断模式下请求（许可）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 为当前线程和给定模式创建节点并插入队列尾部，addWaiter方法前文讲解过</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 操作是否失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，以共享的方式请求获取锁，tryAcquireShared方法前文讲解过</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 成功获取锁，设置头节点和共享模式传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果前驱节点不是头节点或者没有获取锁</span></span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire方法用于判断当前线程是否需要被阻塞，该方法前文讲解过</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并且检测线程是否被中断，该方法前文讲解过</span></span><br><span class="line">                <span class="comment">// 没抢到锁的线程需要被阻塞，避免一直去争抢锁，浪费CPU资源</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        <span class="comment">// 自旋异常退出，取消正在进行锁争抢</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁的逻辑已经完成，再来看看解锁的逻辑。</p><h1 id="Semaphore-release"><a href="#Semaphore-release" class="headerlink" title="Semaphore#release"></a>Semaphore#release</h1><p>release用于释放许可，其方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="comment">// 获取同步状态的值</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 可用的（许可）加上释放的，等于剩余的</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">        <span class="comment">// CAS的方式设置同步状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处依旧是<strong>自旋 + CAS</strong>的操作</p><h2 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="comment">// 记录头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        <span class="comment">// 头节点不为null，且不等于尾结点，说明队列中还有节点</span></span><br><span class="line">        <span class="comment">// 获取头节点等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 头节点等待状态是SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                <span class="comment">// 如果修改节点等待状态失败，进入下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 修改成功后，唤醒后继节点，unparkSuccessor前文讲过</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS是并发编程中比较难的一个类，但是理解AQS非常重要，因为它是JDK中锁和其他同步工具实现的基础</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化有什么作用？序列化与不序列化有什么区别？</title>
      <link href="/blog/2021/03/19/Java-Serializable/"/>
      <url>/blog/2021/03/19/Java-Serializable/</url>
      
        <content type="html"><![CDATA[<h2 id="序列化是干啥用的？"><a href="#序列化是干啥用的？" class="headerlink" title="序列化是干啥用的？"></a><strong>序列化是干啥用的？</strong></h2><p>序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：</p><ul><li><strong>序列化</strong>：把Java对象转换为字节序列。</li><li><strong>反序列化</strong>：把字节序列恢复为原先的Java对象。</li></ul><p><img src="https://pic1.zhimg.com/50/v2-d5b7da5ee39eef8754554efb392e7668_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d5b7da5ee39eef8754554efb392e7668_720w.jpg?source=1940ef5c" alt="img"></p><p>而且序列化机制从某种意义上来说也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。</p><p>事情就是那么个事情，看起来很简单，不过后面的东西还不少，请往下看。</p><span id="more"></span><hr><h2 id="对象如何序列化？"><a href="#对象如何序列化？" class="headerlink" title="对象如何序列化？"></a><strong>对象如何序列化？</strong></h2><p>然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。</p><p>对象的持久化和反持久化需要靠程序员在代码里手动<strong>显式地</strong>进行序列化和反序列化还原的动作。</p><p>举个例子，假如我们要对<code>Student</code>类对象序列化到一个名为<code>student.txt</code>的文本文件中，然后再通过文本文件反序列化成<code>Student</code>类对象：</p><p><img src="https://pic4.zhimg.com/50/v2-b176ec7a4fef630598ee4f69743e56ac_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-b176ec7a4fef630598ee4f69743e56ac_720w.jpg?source=1940ef5c" alt="img"></p><p>1、Student类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student:&quot;</span> + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;name = &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;age = &quot;</span> + <span class="keyword">this</span>.age + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;score = &quot;</span> + <span class="keyword">this</span>.score + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectOutputStream( <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;序列化成功！已经生成student.txt文件&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;==============================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream objectInputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectInputStream( <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    Student student = (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行结果</p><p>控制台打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">序列化成功！已经生成student.txt文件</span><br><span class="line">==============================================</span><br><span class="line">反序列化结果为：</span><br><span class="line">Student:</span><br><span class="line">name = CodeSheep</span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">score = <span class="number">1000</span></span><br></pre></td></tr></table></figure><hr><h2 id="Serializable接口有何用？"><a href="#Serializable接口有何用？" class="headerlink" title="Serializable接口有何用？"></a><strong>Serializable接口有何用？</strong></h2><p>上面在定义<code>Student</code>类时，实现了一个<code>Serializable</code>接口，然而当我们点进<code>Serializable</code>接口内部查看，发现它<strong>竟然是一个空接口</strong>，并没有包含任何方法！</p><p><img src="https://pic2.zhimg.com/50/v2-946e2589cfddb10080f42d072d4ec4fe_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-946e2589cfddb10080f42d072d4ec4fe_720w.jpg?source=1940ef5c" alt="img"></p><p>试想，如果上面在定义<code>Student</code>类时忘了加<code>implements Serializable</code>时会发生什么呢？</p><p>实验结果是：此时的程序运行<strong>会报错</strong>，并抛出<code>NotSerializableException</code>异常：</p><p><img src="https://pic4.zhimg.com/50/v2-2715eb902b48b0d13e2ec788b62d8d99_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-2715eb902b48b0d13e2ec788b62d8d99_720w.jpg?source=1940ef5c" alt="img"></p><p>我们按照错误提示，由源码一直跟到<code>ObjectOutputStream</code>的<code>writeObject0()</code>方法底层一看，才恍然大悟：</p><p><img src="https://pic4.zhimg.com/50/v2-bde7f25f1ed5d0aaf76c12d12554795d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-bde7f25f1ed5d0aaf76c12d12554795d_720w.jpg?source=1940ef5c" alt="img"></p><p>如果一个对象既不是<strong>字符串</strong>、<strong>数组</strong>、<strong>枚举</strong>，而且也没有实现<code>Serializable</code>接口的话，在序列化时就会抛出<code>NotSerializableException</code>异常！</p><p>哦，我明白了！</p><p>原来<code>Serializable</code>接口也仅仅只是做一个标记用！！！</p><p>它告诉代码只要是实现了<code>Serializable</code>接口的类都是可以被序列化的！然而真正的序列化动作不需要靠它完成。</p><hr><h2 id="serialVersionUID号有何用？"><a href="#serialVersionUID号有何用？" class="headerlink" title="serialVersionUID号有何用？"></a><strong><code>serialVersionUID</code>号有何用？</strong></h2><p>相信你一定经常看到有些类中定义了如下代码行，即定义了一个名为<code>serialVersionUID</code>的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4392658638228508589L</span>;</span><br></pre></td></tr></table></figure><p><strong>你知道这句声明的含义吗？为什么要搞一个名为<code>serialVersionUID</code>的序列号？</strong></p><p>继续来做一个简单实验，还拿上面的<code>Student</code>类为例，我们并没有人为在里面显式地声明一个<code>serialVersionUID</code>字段。</p><p>我们首先还是调用上面的<code>serialize()</code>方法，将一个<code>Student</code>对象序列化到本地磁盘上的<code>student.txt</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectOutputStream( <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在<code>Student</code>类里面动点手脚，比如在里面再增加一个名为<code>studentID</code>的字段，表示学生学号：</p><p><img src="https://pic2.zhimg.com/50/v2-d6f5db64071b4ff61a4fdbedcab3a4ec_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d6f5db64071b4ff61a4fdbedcab3a4ec_720w.jpg?source=1940ef5c" alt="img"></p><p>这时候，我们拿刚才已经序列化到本地的<code>student.txt</code>文件，还用如下代码进行反序列化，试图还原出刚才那个<code>Student</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream objectInputStream = </span><br><span class="line">        <span class="keyword">new</span> ObjectInputStream( <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    Student student = (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现<strong>报错了</strong>，并且抛出了<code>InvalidClassException</code>异常：</p><p><img src="https://pic1.zhimg.com/50/v2-21a3779d602dec56312ec2006059d568_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-21a3779d602dec56312ec2006059d568_720w.jpg?source=1940ef5c" alt="img"></p><p>这地方提示的信息非常明确了：序列化前后的<code>serialVersionUID</code>号码不兼容！</p><p>从这地方最起码可以得出<strong>两个</strong>重要信息：</p><ul><li><strong>1、serialVersionUID是序列化前后的唯一标识符</strong></li><li><strong>2、默认如果没有人为显式定义过<code>serialVersionUID</code>，那编译器会为它自动声明一个！</strong></li></ul><p><strong>第1个问题：</strong> <code>serialVersionUID</code>序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。</p><p><strong>第2个问题：</strong> 如果在定义一个可序列化的类时，没有人为显式地给它定义一个<code>serialVersionUID</code>的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的<code>serialVersionUID</code>，一旦像上面一样更改了类的结构或者信息，则类的<code>serialVersionUID</code>也会跟着变化！</p><p>所以，为了<code>serialVersionUID</code>的确定性，写代码时还是建议，凡是<code>implements Serializable</code>的类，都最好人为显式地为它声明一个<code>serialVersionUID</code>明确值！</p><p>当然，如果不想手动赋值，你也可以借助IDE的自动添加功能，比如我使用的<code>IntelliJ IDEA</code>，按<code>alt + enter</code>就可以为类自动生成和添加<code>serialVersionUID</code>字段，十分方便：</p><p><img src="https://pic2.zhimg.com/50/v2-58dd50e1816eb241d3057b41e421da3c_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-58dd50e1816eb241d3057b41e421da3c_720w.jpg?source=1940ef5c" alt="img"></p><hr><h2 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a><strong>两种特殊情况</strong></h2><ul><li>1、凡是被<code>static</code>修饰的字段是不会被序列化的</li><li>2、凡是被<code>transient</code>修饰符修饰的字段也是不会被序列化的</li></ul><p><strong>对于第一点</strong>，因为序列化保存的是<strong>对象的状态</strong>而非类的状态，所以会忽略<code>static</code>静态域也是理所应当的。</p><p><strong>对于第二点</strong>，就需要了解一下<code>transient</code>修饰符的作用了。</p><p>如果在序列化某个类的对象时，就是不希望某个字段被序列化（比如这个字段存放的是隐私值，如：<code>密码</code>等），那这时就可以用<code>transient</code>修饰符来修饰该字段。</p><p>比如在之前定义的<code>Student</code>类中，加入一个<strong>密码字段</strong>，但是不希望序列化到<code>txt</code>文本，则可以：</p><p><img src="https://pic4.zhimg.com/50/v2-2e8e361785961716c6ce2168ad943faa_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-2e8e361785961716c6ce2168ad943faa_720w.jpg?source=1940ef5c" alt="img"></p><p>这样在序列化<code>Student</code>类对象时，<code>password</code>字段会设置为默认值<code>null</code>，这一点可以从反序列化所得到的结果来看出：</p><p><img src="https://pic4.zhimg.com/50/v2-52e8cd9f0b6d2b9c926cbd4d276c95e7_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-52e8cd9f0b6d2b9c926cbd4d276c95e7_720w.jpg?source=1940ef5c" alt="img"></p><hr><h2 id="序列化的受控和加强"><a href="#序列化的受控和加强" class="headerlink" title="序列化的受控和加强"></a><strong>序列化的受控和加强</strong></h2><h2 id="约束性加持"><a href="#约束性加持" class="headerlink" title="约束性加持"></a><strong>约束性加持</strong></h2><p>从上面的过程可以看出，序列化和反序列化的过程其实是<strong>有漏洞的</strong>，因为从序列化到反序列化是有中间过程的，如果被别人拿到了中间字节流，然后加以伪造或者篡改，那反序列化出来的对象就会有一定风险了。</p><p>毕竟反序列化也相当于一种 <strong>“隐式的”对象构造</strong> ，因此我们希望在反序列化时，进行<strong>受控的</strong>对象反序列化动作。</p><p>那怎么个受控法呢？</p><p><strong>答案就是：</strong> 自行编写<code>readObject()</code>函数，用于对象的反序列化构造，从而提供约束性。</p><p>既然自行编写<code>readObject()</code>函数，那就可以做很多可控的事情：比如各种判断工作。</p><p>还以上面的<code>Student</code>类为例，一般来说学生的成绩应该在<code>0 ~ 100</code>之间，我们为了防止学生的考试成绩在反序列化时被别人篡改成一个奇葩值，我们可以自行编写<code>readObject()</code>函数用于反序列化的控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">( ObjectInputStream objectInputStream )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用默认的反序列化函数</span></span><br><span class="line">    objectInputStream.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手工检查反序列化后学生成绩的有效性，若发现有问题，即终止操作！</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> &gt; score || <span class="number">100</span> &lt; score ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;学生分数只能在0到100之间！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我故意将学生的分数改为<code>101</code>，此时反序列化立马终止并且报错：</p><p><img src="https://pic2.zhimg.com/50/v2-4713bd13ff5dba64ffdcc477c7f7f3a2_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4713bd13ff5dba64ffdcc477c7f7f3a2_720w.jpg?source=1940ef5c" alt="img"></p><p>对于上面的代码，有些小伙伴可能会好奇，为什么自定义的<code>private</code>的<code>readObject()</code>方法可以被自动调用，这就需要你跟一下底层源码来一探究竟了，我帮你跟到了<code>ObjectStreamClass</code>类的最底层，看到这里我相信你一定恍然大悟：</p><p><img src="https://pic3.zhimg.com/50/v2-a047fdae29d82d8682e05cf4cbef587a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-a047fdae29d82d8682e05cf4cbef587a_720w.jpg?source=1940ef5c" alt="img"></p><p>又是反射机制在起作用！是的，在Java里，果然万物皆可“反射”（滑稽），即使是类中定义的<code>private</code>私有方法，也能被抠出来执行了，简直引起舒适了。</p><h2 id="单例模式增强"><a href="#单例模式增强" class="headerlink" title="单例模式增强"></a><strong>单例模式增强</strong></h2><p>一个容易被忽略的问题是：<strong>可序列化的单例类有可能并不单例</strong>！</p><p>举个代码小例子就清楚了。</p><p>比如这里我们先用<code>java</code>写一个常见的「静态内部类」方式的单例模式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1576643344804979563L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个验证主函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream =</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将单例对象先序列化到文本文件singleton.txt中</span></span><br><span class="line">        objectOutputStream.writeObject( Singleton.getSingleton() );</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream =</span><br><span class="line">                <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream( <span class="keyword">new</span> File(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将文本文件singleton.txt中的对象反序列化为singleton1</span></span><br><span class="line">        Singleton singleton1 = (Singleton) objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line"></span><br><span class="line">        Singleton singleton2 = Singleton.getSingleton();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行结果竟打印 false ！</span></span><br><span class="line">        System.out.println( singleton1 == singleton2 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后我们发现：<strong>反序列化后的单例对象和原单例对象并不相等</strong>了，这无疑没有达到我们的目标。</p><p><strong>解决办法是</strong>：在单例类中手写<code>readResolve()</code>函数，直接返回单例对象，来规避之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/50/v2-a2eb19f73a2ac3365bb368f10ca0635d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-a2eb19f73a2ac3365bb368f10ca0635d_720w.jpg?source=1940ef5c" alt="img"></p><p>这样一来，当反序列化从流中读取对象时，<code>readResolve()</code>会被调用，用其中返回的对象替代反序列化新建的对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Serializable </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
